---
title: "Enterprise Code Style and Standards"
description: "Naming conventions, formatting rules, linting standards, and TypeScript best practices"
alwaysApply: true
version: "2.0.0"
tags: ["style", "formatting", "linting", "typescript", "enterprise"]
globs:
  - "**/*.{ts,tsx,js,jsx}"
---

## Naming Conventions (Enterprise Standards)

### File Naming
- **Components**: Use kebab-case (`user-profile.tsx`, `navigation-bar.tsx`)
- **Pages**: Use kebab-case (`about-us.tsx`, `contact.tsx`)
- **Utilities**: Use kebab-case (`api-client.ts`, `date-utils.ts`)
- **Types**: Use kebab-case (`user-types.ts`, `api-types.ts`)
- **Tests**: Use kebab-case with suffix (`user-profile.test.tsx`, `api-client.spec.ts`)

### Code Naming
- **Components**: PascalCase (`UserProfile`, `NavigationBar`, `ContactForm`)
- **Functions/Variables**: camelCase (`getUserData`, `isLoading`, `handleSubmit`)
- **Constants**: UPPER_SNAKE_CASE (`API_BASE_URL`, `MAX_RETRY_ATTEMPTS`)
- **Types/Interfaces**: PascalCase (`UserProfile`, `ApiResponse`, `DatabaseConfig`)
- **Enum Values**: UPPER_SNAKE_CASE (`UserStatus.ACTIVE`, `Theme.DARK_MODE`)

### Type Definitions
```typescript
// ✅ Good: Clear interface definitions
interface UserProfile {
  readonly id: UserId // Branded type
  email: string
  name: string
  createdAt: Date
  preferences: UserPreferences
}

type UserId = string & { readonly __brand: unique symbol }
type UserStatus = 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED'

// ✅ Good: Utility types for API responses
type ApiResponse<T> = {
  data: T
  success: true
  timestamp: string
} | {
  error: string
  success: false
  timestamp: string
}

// ✅ Good: Branded types for security
type SanitizedHtml = string & { readonly __htmlSanitized: true }
type ValidatedEmail = string & { readonly __emailValidated: true }
```

## TypeScript Enterprise Standards

### Strict Configuration Requirements
```typescript
// tsconfig.json requirements: strict mode enabled
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}

// ✅ Good: Handling strict TypeScript
function getUserById(id: string): Promise<User | null> {
  // explicit return type, handles null case
}

const user = await getUserById('123')
if (user) { // type guard required
  console.log(user.name) // safe access
}

// ✅ Good: Handling arrays with noUncheckedIndexedAccess
const users: User[] = await getUsers()
const firstUser = users[0] // Type is User | undefined
if (firstUser) {
  console.log(firstUser.name) // safe access
}

// ✅ Good: Optional properties with exactOptionalPropertyTypes
interface UserSettings {
  theme: 'light' | 'dark'
  notifications?: boolean // truly optional, not | undefined
}

const settings: UserSettings = {
  theme: 'light'
  // notifications omitted, not set to undefined
}
```

### Security-First Type Patterns
```typescript
// ✅ Good: Input validation with Zod
import { z } from 'zod'

const userSchema = z.object({
  email: z.string().email().toLowerCase(),
  name: z.string().min(2).max(50).trim(),
  age: z.number().int().min(13).max(120)
})

type ValidatedUser = z.infer<typeof userSchema>

// ✅ Good: Type-safe API functions
export async function createUser(input: unknown): Promise<ApiResponse<User>> {
  const validation = userSchema.safeParse(input)
  
  if (!validation.success) {
    return {
      success: false,
      error: 'Invalid input data',
      timestamp: new Date().toISOString()
    }
  }
  
  // validation.data is now ValidatedUser type
  const user = await saveUser(validation.data)
  
  return {
    success: true,
    data: user,
    timestamp: new Date().toISOString()
  }
}
```

## Indentation and Formatting

### Code Formatting Standards
```typescript
// ✅ Good: Consistent formatting
const userProfile: UserProfile = {
  id: 'user_123',
  email: 'user@example.com',
  name: 'John Doe',
  createdAt: new Date(),
  preferences: {
    theme: 'dark',
    notifications: true,
    language: 'en',
  }, // trailing comma required
}

// ✅ Good: Multi-line function signatures
export async function updateUserProfile(
  userId: UserId,
  updates: Partial<UserProfile>,
  options: {
    validateEmail?: boolean
    sendNotification?: boolean
  } = {}
): Promise<ApiResponse<UserProfile>> {
  // Function implementation
}

// ✅ Good: Destructuring with proper spacing
const {
  email,
  name,
  preferences: {
    theme,
    notifications = false, // default value
  },
} = userProfile
```

### Spacing and Line Length
- **Indentation**: 2 spaces (no tabs)
- **Line length**: 100 characters max (configurable in prettier)
- **Quotes**: Single quotes for strings, double quotes for JSX attributes
- **Trailing commas**: Required in multi-line objects/arrays
- **Semicolons**: Required (automatic insertion can be problematic)

## Import Organization (Enterprise Standards)

### Import Grouping and Sorting
```typescript
// ✅ Good: Properly organized imports
// 1. Node.js built-ins
import path from 'node:path'
import fs from 'node:fs/promises'

// 2. External packages (sorted alphabetically)
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

// 3. Internal modules (sorted alphabetically by path)
import { auth } from '@/lib/auth'
import { ratelimit } from '@/lib/rate-limit'
import { prisma } from '@/lib/prisma'

// 4. Relative imports
import { validateRequest } from '../utils/validation'
import { UserCard } from './user-card'

// 5. Type-only imports (grouped separately)
import type { User } from '@/types/user'
import type { NextApiRequest } from 'next'
```

### Path Aliases Configuration
```typescript
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@/components/*": ["components/*"],
      "@/lib/*": ["lib/*"],
      "@/types/*": ["types/*"],
      "@/hooks/*": ["hooks/*"]
    }
  }
}

// ✅ Good: Using path aliases
import { Button } from '@/components/ui/button'
import { getUserById } from '@/lib/data/users'
import type { ApiResponse } from '@/types/api'

// ❌ Avoid: Relative imports for shared modules
import { Button } from '../../../components/ui/button'
```

## Code Documentation and Comments

### JSDoc Standards
```typescript
/**
 * Retrieves user profile data with security checks and validation.
 * 
 * @param userId - The unique identifier for the user
 * @param options - Configuration options for the query
 * @param options.includePrivateData - Whether to include sensitive information (requires admin access)
 * @param options.validatePermissions - Whether to perform additional permission checks
 * @returns Promise that resolves to user profile or null if not found
 * 
 * @throws {AuthenticationError} When user is not authenticated
 * @throws {AuthorizationError} When user lacks required permissions
 * @throws {ValidationError} When userId format is invalid
 * 
 * @example
 * ```typescript
 * const user = await getUserProfile('user_123', {
 *   includePrivateData: false,
 *   validatePermissions: true
 * })
 * ```
 */
export async function getUserProfile(
  userId: UserId,
  options: {
    includePrivateData?: boolean
    validatePermissions?: boolean
  } = {}
): Promise<UserProfile | null> {
  // Implementation
}
```

### Comment Guidelines
```typescript
// ✅ Good: Explaining business logic and "why"
export function calculateUserSubscriptionDiscount(user: User): number {
  // Apply loyalty discount for users with 2+ years membership
  // This implements the 2023 business policy for customer retention
  if (user.memberSince && differenceInYears(new Date(), user.memberSince) >= 2) {
    return 0.15 // 15% discount
  }
  
  // Student discount requires verified .edu email domain
  if (user.email.endsWith('.edu')) {
    return 0.10 // 10% student discount
  }
  
  return 0 // No discount
}

// ❌ Bad: Explaining obvious code
function getUserName(user: User): string {
  // Get the user's name from the user object
  return user.name
}
```

## ESLint and Prettier Configuration

### Enterprise ESLint Rules
```json
{
  "extends": [
    "next/core-web-vitals",
    "@typescript-eslint/recommended-type-checked",
    "plugin:security/recommended",
    "plugin:jsx-a11y/strict"
  ],
  "rules": {
    // Security rules
    "security/detect-object-injection": "error",
    "security/detect-non-literal-fs-filename": "error",
    
    // TypeScript rules
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error",
    
    // Import rules
    "import/order": ["error", {
      "groups": [
        "builtin",
        "external", 
        "internal",
        "parent",
        "sibling",
        "index",
        "type"
      ]
    }],
    
    // React/Next.js rules
    "react/no-unescaped-entities": "error",
    "react-hooks/exhaustive-deps": "error"
  }
}
```

### Prettier Configuration
```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "useTabs": false,
  "quoteProps": "as-needed",
  "bracketSpacing": true,
  "bracketSameLine": false,
  "arrowParens": "avoid"
}
```

## File Organization (Enterprise Architecture)

### Feature-Based Structure
```
src/
├── app/                          # Next.js App Router
│   ├── (auth)/                  # Route groups
│   ├── api/                     # API routes
│   └── globals.css              
├── components/                   # Shared UI components
│   ├── ui/                      # Base design system
│   ├── forms/                   # Form components
│   └── layout/                  # Layout components
├── features/                     # Feature modules
│   └── user-management/
│       ├── components/          # Feature-specific components
│       ├── hooks/               # Feature-specific hooks
│       ├── services/            # Business logic
│       ├── types/               # Feature types
│       └── utils/               # Feature utilities
├── lib/                         # Shared utilities
│   ├── auth/                    # Authentication logic
│   ├── database/                # Database utilities
│   ├── validations/             # Zod schemas
│   └── utils/                   # General utilities
└── types/                       # Global type definitions
```

### Co-location Standards
```typescript
// ✅ Good: Co-locate related files
components/
└── user-profile/
    ├── user-profile.tsx         # Main component
    ├── user-profile.test.tsx    # Tests
    ├── user-profile.stories.tsx # Storybook stories
    ├── user-avatar.tsx          # Sub-component
    └── index.ts                 # Clean exports

// index.ts
export { UserProfile } from './user-profile'
export type { UserProfileProps } from './user-profile'
```

## Code Quality Standards (Enterprise Grade)

### Function Design
```typescript
// ✅ Good: Single responsibility, clear purpose
export function validateEmailAddress(email: string): ValidatedEmail | null {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  
  if (!emailRegex.test(email)) {
    return null
  }
  
  return email.toLowerCase().trim() as ValidatedEmail
}

// ✅ Good: Early returns, reduced nesting
export function calculateShippingCost(
  order: Order,
  destination: Address
): number {
  if (order.total >= FREE_SHIPPING_THRESHOLD) {
    return 0
  }
  
  if (destination.country !== 'US') {
    return INTERNATIONAL_SHIPPING_RATE
  }
  
  if (destination.isRemote) {
    return REMOTE_SHIPPING_RATE
  }
  
  return STANDARD_SHIPPING_RATE
}

// ❌ Bad: Deep nesting, complex logic
export function processOrder(order: Order): OrderResult {
  if (order) {
    if (order.items) {
      if (order.items.length > 0) {
        if (order.customer) {
          if (order.customer.isVerified) {
            // Deep nested logic
          }
        }
      }
    }
  }
}
```

### Error Handling Patterns
```typescript
// ✅ Good: Discriminated unions for error handling
type UserResult = 
  | { success: true; user: User }
  | { success: false; error: UserError }

type UserError = 
  | { type: 'NOT_FOUND'; message: string }
  | { type: 'VALIDATION_FAILED'; details: ValidationError[] }
  | { type: 'AUTHORIZATION_FAILED'; message: string }

export async function getUser(id: UserId): Promise<UserResult> {
  try {
    const user = await prisma.user.findUnique({ where: { id } })
    
    if (!user) {
      return {
        success: false,
        error: { type: 'NOT_FOUND', message: 'User not found' }
      }
    }
    
    return { success: true, user }
  } catch (error) {
    console.error('Database error:', error)
    return {
      success: false,
      error: { type: 'AUTHORIZATION_FAILED', message: 'Access denied' }
    }
  }
}
```

This enterprise code style ensures consistency, security, maintainability, and scalability across large development teams.
