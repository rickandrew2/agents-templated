---
title: "Enterprise Frontend Development Guidelines"
description: "React, Next.js, Tailwind CSS patterns with security and accessibility"
alwaysApply: true
version: "2.0.0"
tags: ["frontend", "react", "nextjs", "tailwind", "security", "accessibility"]
globs:
  - "app/**/*"
  - "components/**/*"
  - "hooks/**/*"
---

## Next.js App Router (Enterprise Patterns)

- **Server Components by default**: Maximize performance and SEO
- **"use client" sparingly**: Only for interactivity, hooks, browser APIs
- **Server Actions**: Use for form submissions and mutations with proper validation
- **Route Handlers**: API endpoints with comprehensive security (auth, validation, rate limiting)
- **Error boundaries**: Implement `error.tsx` and `loading.tsx` for proper UX
- **Metadata API**: Use for SEO optimization and social sharing

### Security-First Component Development

```typescript
// ✅ Good: Secure form handling with validation
'use client'

import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'
import { contactFormSchema, type ContactFormData } from '@/lib/validations'

export function ContactForm() {
  const form = useForm<ContactFormData>({
    resolver: zodResolver(contactFormSchema),
    defaultValues: {
      email: '',
      message: ''
    }
  })
  
  const onSubmit = async (data: ContactFormData) => {
    // Client-side validation already done by resolver
    const result = await submitContactForm(data)
    if (result.success) {
      form.reset()
      // Show success message
    }
  }
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email *
        </label>
        <input
          {...form.register('email')}
          type="email"
          id="email"
          aria-describedby={form.formState.errors.email ? "email-error" : undefined}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 focus:border-blue-500 focus:ring-blue-500"
        />
        {form.formState.errors.email && (
          <p id="email-error" role="alert" className="mt-1 text-sm text-red-600">
            {form.formState.errors.email.message}
          </p>
        )}
      </div>
      
      <button
        type="submit"
        disabled={form.formState.isSubmitting}
        className="w-full rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 disabled:opacity-50"
      >
        {form.formState.isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  )
}
```

## React Patterns (Enterprise Standards)

### Component Architecture
```typescript
// ✅ Good: Named export with comprehensive TypeScript
interface UserProfileProps {
  userId: string
  showEmail?: boolean
  onEdit?: () => void
}

export function UserProfile({ userId, showEmail = false, onEdit }: UserProfileProps) {
  const { data: user, error, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => getUserById(userId)
  })
  
  if (isLoading) return <UserProfileSkeleton />
  if (error) return <ErrorMessage error={error} />
  if (!user) return <div>User not found</div>
  
  return (
    <div className="rounded-lg border border-gray-200 p-6">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">{user.name}</h2>
        {onEdit && (
          <button
            onClick={onEdit}
            className="text-blue-600 hover:text-blue-800"
            aria-label={`Edit ${user.name}'s profile`}
          >
            Edit
          </button>
        )}
      </div>
      {showEmail && (
        <p className="mt-2 text-gray-600">{user.email}</p>
      )}
    </div>
  )
}
```

### Security Patterns
- **Input sanitization**: Always validate and sanitize user inputs
- **XSS prevention**: Use React's built-in protection, avoid dangerouslySetInnerHTML
- **Authentication**: Check user permissions before rendering sensitive components
- **Error boundaries**: Never expose sensitive information in error messages

## Accessibility (WCAG 2.1 AA Compliance)

### Required Patterns
```typescript
// ✅ Good: Accessible form component
export function AccessibleForm() {
  return (
    <form noValidate>
      {/* Proper labels and ARIA attributes */}
      <div>
        <label htmlFor="username" className="block text-sm font-medium">
          Username *
        </label>
        <input
          id="username"
          type="text"
          required
          aria-describedby="username-help username-error"
          className="mt-1 block w-full"
        />
        <div id="username-help" className="mt-1 text-sm text-gray-600">
          Choose a unique username with 3-20 characters
        </div>
        <div id="username-error" role="alert" className="mt-1 text-sm text-red-600">
          {/* Error message */}
        </div>
      </div>
      
      {/* Keyboard navigation */}
      <button
        type="submit"
        className="focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      >
        Create Account
      </button>
    </form>
  )
}

// ✅ Good: Accessible modal
export function Modal({ isOpen, onClose, children }: ModalProps) {
  useEffect(() => {
    if (isOpen) {
      // Trap focus, prevent body scroll
      document.body.style.overflow = 'hidden'
      return () => {
        document.body.style.overflow = ''
      }
    }
  }, [isOpen])
  
  if (!isOpen) return null
  
  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div
        className="max-w-md rounded-lg bg-white p-6"
        onClick={e => e.stopPropagation()}
      >
        {children}
      </div>
    </div>
  )
}
```

### Accessibility Checklist
- [ ] All interactive elements are keyboard accessible
- [ ] Form fields have proper labels and error messages
- [ ] Color contrast meets WCAG AA standards (4.5:1 for normal text)
- [ ] Images have meaningful alt attributes
- [ ] Headings follow logical hierarchy (h1 → h2 → h3)
- [ ] ARIA attributes used appropriately for screen readers
- [ ] Focus indicators are visible and clear

## Performance Optimization

### Core Web Vitals Optimization
```typescript
// ✅ Good: Optimized image component
import Image from 'next/image'

export function ProductCard({ product }: { product: Product }) {
  return (
    <div className="rounded-lg border">
      <Image
        src={product.image}
        alt={product.name}
        width={300}
        height={200}
        className="rounded-t-lg object-cover"
        priority={product.featured} // Only for above-the-fold images
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..." // Generate with plaiceholder
      />
      <div className="p-4">
        <h3 className="font-semibold">{product.name}</h3>
        <p className="text-gray-600">${product.price}</p>
      </div>
    </div>
  )
}

// ✅ Good: Lazy loading below the fold
import dynamic from 'next/dynamic'

const LazyChart = dynamic(() => import('@/components/Chart'), {
  loading: () => <ChartSkeleton />
})

export function Dashboard() {
  return (
    <div>
      <h1>Analytics Dashboard</h1>
      {/* Above the fold content */}
      <div className="grid grid-cols-3 gap-4 mb-8">
        <StatCard title="Revenue" value="$12,345" />
        <StatCard title="Users" value="1,234" />
        <StatCard title="Orders" value="567" />
      </div>
      
      {/* Below the fold - lazy loaded */}
      <LazyChart />
    </div>
  )
}
```

### Bundle Optimization
- Use dynamic imports for large components
- Implement code splitting at route level
- Use `next/image` for all images
- Monitor bundle size with `npm run analyze`
- Lazy load non-critical components

## Tailwind CSS (Design System Approach)

### Consistent Design Tokens
```typescript
// tailwind.config.ts - Define design system
export default {
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8'
        },
        gray: {
          50: '#f9fafb',
          600: '#4b5563',
          900: '#111827'
        }
      },
      spacing: {
        '18': '4.5rem',
        '88': '22rem'
      }
    }
  }
}

// Component usage
export function Button({ variant = 'primary', children, ...props }: ButtonProps) {
  const baseClasses = 'inline-flex items-center justify-center rounded-md px-4 py-2 text-sm font-medium transition-colors focus:ring-2 focus:ring-offset-2 disabled:opacity-50'
  
  const variants = {
    primary: 'bg-primary-600 text-white hover:bg-primary-700 focus:ring-primary-500',
    secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200 focus:ring-gray-500',
    outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
  }
  
  return (
    <button
      className={`${baseClasses} ${variants[variant]}`}
      {...props}
    >
      {children}
    </button>
  )
}
```

### Responsive Design
- Mobile-first approach (use `sm:`, `md:`, `lg:` prefixes)
- Test on multiple screen sizes
- Use responsive typography (`text-sm md:text-base`)
- Implement responsive layout changes (`flex-col lg:flex-row`)

## State Management (Enterprise Patterns)

### Local State
```typescript
// ✅ Good: Local state with proper TypeScript
export function UserSettings() {
  const [settings, setSettings] = useState<UserSettings>({
    notifications: true,
    theme: 'light',
    language: 'en'
  })
  
  const updateSetting = useCallback(<K extends keyof UserSettings>(
    key: K,
    value: UserSettings[K]
  ) => {
    setSettings(prev => ({ ...prev, [key]: value }))
  }, [])
  
  return (
    <div className="space-y-4">
      <Toggle
        checked={settings.notifications}
        onChange={value => updateSetting('notifications', value)}
        label="Email notifications"
      />
    </div>
  )
}
```

### Global State
- Use React Query/TanStack Query for server state
- Use Zustand or Jotai for client-side global state
- Context API for theme/auth state only
- Avoid prop drilling beyond 2-3 levels

## Testing Frontend Components

```typescript
// Component testing with accessibility
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

describe('ContactForm', () => {
  it('submits form with valid data', async () => {
    const user = userEvent.setup()
    const onSubmit = vi.fn()
    
    render(<ContactForm onSubmit={onSubmit} />)
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com')
    await user.type(screen.getByLabelText(/message/i), 'Hello world')
    await user.click(screen.getByRole('button', { name: /submit/i }))
    
    expect(onSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      message: 'Hello world'
    })
  })
  
  it('has no accessibility violations', async () => {
    const { container } = render(<ContactForm onSubmit={vi.fn()} />)
    const results = await axe(container)
    expect(results).toHaveNoViolations()
  })
})
```

This enterprise frontend approach ensures security, accessibility, performance, and maintainability at scale.
