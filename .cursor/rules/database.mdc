---
title: "Database and Backend Guidelines"
description: "Database-agnostic patterns with Prisma and Supabase variants"
alwaysApply: true
version: "2.0.0"
tags: ["database", "backend", "prisma", "supabase", "typescript"]
globs:
  - "lib/**/*"
  - "app/api/**/*"
  - "prisma/**/*"
---

# Database Strategy Selection

**IMPORTANT**: This template supports TWO distinct database approaches. Choose ONE for your project consistency.

## Decision Guide

### Choose Prisma + PostgreSQL when:
- ✅ Complex relational schemas with custom business logic
- ✅ Maximum type safety and compile-time schema validation
- ✅ Custom database constraints and advanced SQL features
- ✅ Multi-database support (PostgreSQL, MySQL, SQLite)
- ✅ Existing database schema to migrate
- ✅ Team prefers ORM approach with migrations

### Choose Supabase when:
- ✅ Rapid prototyping and MVP development
- ✅ Built-in authentication, real-time, and storage needed
- ✅ Row Level Security (RLS) for multi-tenant apps
- ✅ Real-time subscriptions and collaborative features
- ✅ Edge functions and serverless database
- ✅ Team prefers BaaS (Backend as a Service) approach

**Once chosen, remove the unused approach from your project to avoid confusion.**

---

# PRISMA VARIANT PATTERNS

Use these patterns if you chose Prisma as your database strategy.

## Required Dependencies

```json
{
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "prisma": "^5.15.0"
  }
}
```

## Prisma Setup

### Database Client Configuration

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error']
})

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

### Schema Patterns

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  posts     Post[]
  sessions  Session[]

  @@map("users")
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("posts")
}

enum Role {
  USER
  ADMIN
}
```

### Data Access Patterns

```typescript
// lib/data/users.ts
import { prisma } from '@/lib/prisma'
import { Prisma } from '@prisma/client'

export async function getUserById(id: string) {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true
      }
    })
    return user
  } catch (error) {
    console.error('Database error:', error)
    return null
  }
}

export async function createUser(data: Prisma.UserCreateInput) {
  try {
    const user = await prisma.user.create({
      data,
      select: {
        id: true,
        email: true,
        name: true,
        role: true
      }
    })
    return user
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2002') {
        throw new Error('Email already exists')
      }
    }
    throw error
  }
}

// Pagination pattern
export async function getUsers(
  page: number = 1,
  limit: number = 10,
  search?: string
) {
  const skip = (page - 1) * limit
  
  const where: Prisma.UserWhereInput = search
    ? {
        OR: [
          { email: { contains: search, mode: 'insensitive' } },
          { name: { contains: search, mode: 'insensitive' } }
        ]
      }
    : {}

  const [users, total] = await Promise.all([
    prisma.user.findMany({
      where,
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true
      },
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' }
    }),
    prisma.user.count({ where })
  ])

  return {
    users,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  }
}
```

### Server Actions with Prisma

```typescript
// app/actions/user.ts
'use server'

import { auth } from '@/app/api/auth/[...nextauth]/route'
import { prisma } from '@/lib/prisma'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

const updateUserSchema = z.object({
  name: z.string().min(2).max(50),
  email: z.string().email()
})

export async function updateUser(
  userId: string,
  data: z.infer<typeof updateUserSchema>
) {
  const session = await auth()
  if (!session || session.user.id !== userId) {
    throw new Error('Unauthorized')
  }

  const validatedData = updateUserSchema.parse(data)

  try {
    const user = await prisma.user.update({
      where: { id: userId },
      data: validatedData,
      select: {
        id: true,
        name: true,
        email: true
      }
    })

    revalidatePath('/dashboard/profile')
    return { success: true, user }
  } catch (error) {
    console.error('Update user error:', error)
    throw new Error('Failed to update user')
  }
}
```

---

# SUPABASE VARIANT PATTERNS

Use these patterns if you chose Supabase as your database strategy.

## Required Dependencies

```json
{
  "dependencies": {
    "@supabase/supabase-js": "^2.45.0",
    "@supabase/ssr": "^0.4.0"
  }
}
```

## Supabase Setup

### Client Configuration

```typescript
// lib/supabase/client.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from '@/types/database'

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL')
}
if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_ANON_KEY')
}

export const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
)
```

### Server Client Configuration

```typescript
// lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { Database } from '@/types/database'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options)
            })
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

### Type Generation

```typescript
// types/database.ts (generate with: supabase gen types typescript)
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: string
          email: string
          name: string | null
          role: 'user' | 'admin'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          email: string
          name?: string | null
          role?: 'user' | 'admin'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          name?: string | null
          role?: 'user' | 'admin'
          updated_at?: string
        }
      }
      posts: {
        Row: {
          id: string
          title: string
          content: string | null
          published: boolean
          author_id: string
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          title: string
          content?: string | null
          published?: boolean
          author_id: string
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          title?: string
          content?: string | null
          published?: boolean
          author_id?: string
          updated_at?: string
        }
      }
    }
  }
}
```

### Data Access Patterns with RLS

```typescript
// lib/data/users.ts
import { createClient } from '@/lib/supabase/server'

export async function getUserById(id: string) {
  const supabase = await createClient()
  
  const { data: user, error } = await supabase
    .from('users')
    .select('id, email, name, role, created_at')
    .eq('id', id)
    .single()

  if (error) {
    console.error('Database error:', error)
    return null
  }

  return user
}

export async function createUser(userData: {
  email: string
  name?: string
  role?: 'user' | 'admin'
}) {
  const supabase = await createClient()
  
  const { data: user, error } = await supabase
    .from('users')
    .insert(userData)
    .select('id, email, name, role')
    .single()

  if (error) {
    if (error.code === '23505') { // Unique constraint violation
      throw new Error('Email already exists')
    }
    throw error
  }

  return user
}

export async function getUsers(
  page: number = 1,
  limit: number = 10,
  search?: string
) {
  const supabase = await createClient()
  const offset = (page - 1) * limit

  let query = supabase
    .from('users')
    .select('id, email, name, role, created_at', { count: 'exact' })

  if (search) {
    query = query.or(`email.ilike.%${search}%,name.ilike.%${search}%`)
  }

  const { data: users, error, count } = await query
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1)

  if (error) {
    throw error
  }

  return {
    users,
    pagination: {
      page,
      limit,
      total: count || 0,
      totalPages: Math.ceil((count || 0) / limit)
    }
  }
}
```

### Real-time Subscriptions

```typescript
// hooks/use-realtime-posts.ts
'use client'

import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabase/client'
import { Database } from '@/types/database'

type Post = Database['public']['Tables']['posts']['Row']

export function useRealtimePosts() {
  const [posts, setPosts] = useState<Post[]>([])

  useEffect(() => {
    // Subscribe to changes
    const subscription = supabase
      .channel('posts-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'posts'
        },
        (payload) => {
          if (payload.eventType === 'INSERT') {
            setPosts(prev => [payload.new as Post, ...prev])
          } else if (payload.eventType === 'UPDATE') {
            setPosts(prev => prev.map(p => 
              p.id === payload.new.id ? payload.new as Post : p
            ))
          } else if (payload.eventType === 'DELETE') {
            setPosts(prev => prev.filter(p => p.id !== payload.old.id))
          }
        }
      )
      .subscribe()

    return () => {
      subscription.unsubscribe()
    }
  }, [])

  return posts
}
```

---

# SHARED PATTERNS (Both Variants)

## API Route Error Handling

```typescript
// For both Prisma and Supabase
export function handleDatabaseError(error: unknown): NextResponse {
  if (error instanceof Error) {
    // Check for common constraint violations
    if (error.message.includes('already exists')) {
      return NextResponse.json(
        { error: 'Resource already exists' },
        { status: 409 }
      )
    }
  }

  console.error('Database error:', error)
  return NextResponse.json(
    { error: 'Database operation failed' },
    { status: 500 }
  )
}
```

## Data Validation Patterns

```typescript
// lib/validations/user.ts
import { z } from 'zod'

export const createUserSchema = z.object({
  email: z.string().email('Invalid email').toLowerCase(),
  name: z.string().min(2, 'Name too short').max(50, 'Name too long').optional(),
  role: z.enum(['user', 'admin']).optional()
})

export const updateUserSchema = createUserSchema.partial().extend({
  id: z.string().min(1, 'ID required')
})

export type CreateUserInput = z.infer<typeof createUserSchema>
export type UpdateUserInput = z.infer<typeof updateUserSchema>
```

## Caching Strategies

```typescript
// Next.js App Router caching
export const revalidate = 60 // Revalidate every 60 seconds

// React Query patterns (for client-side caching)
export function useUsers(page: number, search?: string) {
  return useQuery({
    queryKey: ['users', page, search],
    queryFn: () => fetchUsers(page, search),
    staleTime: 30 * 1000, // 30 seconds
  })
}
```

## Testing Patterns

```typescript
// __tests__/lib/data/users.test.ts
import { getUserById } from '@/lib/data/users'

// For Prisma
jest.mock('@/lib/prisma', () => ({
  prisma: {
    user: {
      findUnique: jest.fn()
    }
  }
}))

// For Supabase  
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(() => ({
    from: jest.fn(() => ({
      select: jest.fn(() => ({
        eq: jest.fn(() => ({
          single: jest.fn()
        }))
      }))
    }))
  }))
}))
```

Remember: Choose ONE database approach and remove the other patterns from your implementation to maintain consistency and avoid confusion.
