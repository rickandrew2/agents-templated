# Testing Guidelines & Best Practices

Comprehensive testing patterns for unit, integration, and E2E testing with Vitest and Playwright.

## Core Testing Principles

- **Test Pyramid**: More unit tests, fewer integration tests, minimal E2E tests
- **Arrange-Act-Assert**: Structure tests clearly with setup, action, and verification
- **Descriptive Names**: Test names should describe expected behavior
- **Independent Tests**: Each test should be able to run in isolation
- **Fast Feedback**: Unit tests should run quickly (<500ms each)

## Unit Testing with Vitest

### Component Testing Patterns

```typescript
// __tests__/components/Button.test.tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Button } from '@/components/ui/Button'

describe('Button Component', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument()
  })

  it('calls onClick handler when clicked', async () => {
    const user = userEvent.setup()
    const handleClick = vi.fn()
    
    render(<Button onClick={handleClick}>Click me</Button>)
    await user.click(screen.getByRole('button'))
    
    expect(handleClick).toHaveBeenCalledOnce()
  })

  it('applies disabled state correctly', () => {
    render(<Button disabled>Disabled</Button>)
    expect(screen.getByRole('button')).toBeDisabled()
  })

  it('renders with correct variant classes', () => {
    render(<Button variant="destructive">Delete</Button>)
    expect(screen.getByRole('button')).toHaveClass('bg-destructive')
  })
})
```

### Hook Testing Patterns

```typescript
// __tests__/hooks/use-counter.test.ts
import { renderHook, act } from '@testing-library/react'
import { useCounter } from '@/hooks/use-counter'

describe('useCounter Hook', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter())
    expect(result.current.count).toBe(0)
  })

  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(42))
    expect(result.current.count).toBe(42)
  })

  it('increments counter', () => {
    const { result } = renderHook(() => useCounter())
    
    act(() => {
      result.current.increment()
    })
    
    expect(result.current.count).toBe(1)
  })

  it('decrements counter', () => {
    const { result } = renderHook(() => useCounter(5))
    
    act(() => {
      result.current.decrement()
    })
    
    expect(result.current.count).toBe(4)
  })

  it('resets counter to initial value', () => {
    const { result } = renderHook(() => useCounter(10))
    
    act(() => {
      result.current.increment()
      result.current.reset()
    })
    
    expect(result.current.count).toBe(10)
  })
})
```

### API Route Testing

```typescript
// __tests__/api/users.test.ts
import { createMocks } from 'node-mocks-http'
import handler from '@/app/api/users/route'
import { prisma } from '@/lib/prisma'
import { auth } from '@/app/api/auth/[...nextauth]/route'

// Mock dependencies
vi.mock('@/lib/prisma', () => ({
  prisma: {
    user: {
      create: vi.fn(),
      findMany: vi.fn(),
      findUnique: vi.fn(),
      update: vi.fn(),
      delete: vi.fn()
    }
  }
}))

vi.mock('@/app/api/auth/[...nextauth]/route', () => ({
  auth: vi.fn()
}))

describe('/api/users', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('GET /api/users', () => {
    it('returns users when authenticated', async () => {
      // Mock authentication
      (auth as any).mockResolvedValue({
        user: { id: '1', role: 'admin' }
      })

      // Mock database
      (prisma.user.findMany as any).mockResolvedValue([
        { id: '1', email: 'test@example.com', name: 'Test User' }
      ])

      const { req, res } = createMocks({
        method: 'GET'
      })

      await handler.GET(req)

      expect(res._getStatusCode()).toBe(200)
      const data = JSON.parse(res._getData())
      expect(data.users).toHaveLength(1)
      expect(data.users[0]).toMatchObject({
        id: '1',
        email: 'test@example.com'
      })
    })

    it('returns 401 when not authenticated', async () => {
      (auth as any).mockResolvedValue(null)

      const { req, res } = createMocks({
        method: 'GET'
      })

      await handler.GET(req)

      expect(res._getStatusCode()).toBe(401)
      expect(JSON.parse(res._getData())).toMatchObject({
        error: 'Unauthorized'
      })
    })
  })

  describe('POST /api/users', () => {
    it('creates user with valid data', async () => {
      (auth as any).mockResolvedValue({
        user: { id: '1', role: 'admin' }
      })

      const userData = {
        email: 'new@example.com',
        name: 'New User'
      }

      (prisma.user.create as any).mockResolvedValue({
        id: '2',
        ...userData
      })

      const { req, res } = createMocks({
        method: 'POST',
        body: userData
      })

      await handler.POST(req)

      expect(res._getStatusCode()).toBe(201)
      expect(prisma.user.create).toHaveBeenCalledWith({
        data: userData,
        select: expect.objectContaining({
          id: true,
          email: true,
          name: true
        })
      })
    })

    it('returns 400 with invalid data', async () => {
      (auth as any).mockResolvedValue({
        user: { id: '1', role: 'admin' }
      })

      const { req, res } = createMocks({
        method: 'POST',
        body: {
          email: 'invalid-email', // Invalid email
          name: 'A' // Too short
        }
      })

      await handler.POST(req)

      expect(res._getStatusCode()).toBe(400)
      expect(JSON.parse(res._getData())).toMatchObject({
        error: expect.stringContaining('Validation')
      })
    })
  })
})
```

### Database Testing (Prisma)

```typescript
// __tests__/lib/data/users.test.ts
import { getUserById, createUser } from '@/lib/data/users'
import { prisma } from '@/lib/prisma'

vi.mock('@/lib/prisma', () => ({
  prisma: {
    user: {
      findUnique: vi.fn(),
      create: vi.fn()
    }
  }
}))

describe('User Data Functions', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getUserById', () => {
    it('returns user when found', async () => {
      const mockUser = {
        id: '1',
        email: 'test@example.com',
        name: 'Test User'
      }

      (prisma.user.findUnique as any).mockResolvedValue(mockUser)

      const result = await getUserById('1')

      expect(result).toEqual(mockUser)
      expect(prisma.user.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
        select: expect.objectContaining({
          id: true,
          email: true,
          name: true
        })
      })
    })

    it('returns null when user not found', async () => {
      (prisma.user.findUnique as any).mockResolvedValue(null)

      const result = await getUserById('nonexistent')

      expect(result).toBeNull()
    })

    it('returns null on database error', async () => {
      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
      
      (prisma.user.findUnique as any).mockRejectedValue(new Error('DB Error'))

      const result = await getUserById('1')

      expect(result).toBeNull()
      expect(consoleSpy).toHaveBeenCalledWith('Database error:', expect.any(Error))
      
      consoleSpy.mockRestore()
    })
  })

  describe('createUser', () => {
    it('creates user successfully', async () => {
      const userData = {
        email: 'new@example.com',
        name: 'New User'
      }

      const createdUser = {
        id: '2',
        ...userData,
        role: 'user'
      }

      (prisma.user.create as any).mockResolvedValue(createdUser)

      const result = await createUser(userData)

      expect(result).toEqual(createdUser)
      expect(prisma.user.create).toHaveBeenCalledWith({
        data: userData,
        select: expect.objectContaining({
          id: true,
          email: true,
          name: true,
          role: true
        })
      })
    })

    it('throws error for duplicate email', async () => {
      const userData = {
        email: 'existing@example.com',
        name: 'User'
      }

      const prismaError = new Error('Unique constraint failed')
      ;(prismaError as any).code = 'P2002'
      
      (prisma.user.create as any).mockRejectedValue(prismaError)

      await expect(createUser(userData)).rejects.toThrow('Email already exists')
    })
  })
})
```

## E2E Testing with Playwright

### Page Object Model

```typescript
// e2e/pages/auth-page.ts
import { Page, Locator } from '@playwright/test'

export class AuthPage {
  readonly page: Page
  readonly emailInput: Locator
  readonly passwordInput: Locator
  readonly signInButton: Locator
  readonly signUpButton: Locator
  readonly errorMessage: Locator

  constructor(page: Page) {
    this.page = page
    this.emailInput = page.getByTestId('email-input')
    this.passwordInput = page.getByTestId('password-input')
    this.signInButton = page.getByRole('button', { name: /sign in/i })
    this.signUpButton = page.getByRole('button', { name: /sign up/i })
    this.errorMessage = page.getByTestId('error-message')
  }

  async goto() {
    await this.page.goto('/auth/signin')
  }

  async signIn(email: string, password: string) {
    await this.emailInput.fill(email)
    await this.passwordInput.fill(password)
    await this.signInButton.click()
  }

  async expectSignInError(message: string) {
    await expect(this.errorMessage).toContainText(message)
  }
}
```

### E2E Test Examples

```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test'
import { AuthPage } from './pages/auth-page'

test.describe('Authentication Flow', () => {
  test('user can sign in with valid credentials', async ({ page }) => {
    const authPage = new AuthPage(page)
    
    await authPage.goto()
    await authPage.signIn('test@example.com', 'password123')
    
    // Should redirect to dashboard
    await expect(page).toHaveURL('/dashboard')
    await expect(page.getByText('Welcome back!')).toBeVisible()
  })

  test('user sees error with invalid credentials', async ({ page }) => {
    const authPage = new AuthPage(page)
    
    await authPage.goto()
    await authPage.signIn('invalid@example.com', 'wrongpassword')
    
    await authPage.expectSignInError('Invalid credentials')
  })

  test('user can sign out', async ({ page }) => {
    // First sign in
    const authPage = new AuthPage(page)
    await authPage.goto()
    await authPage.signIn('test@example.com', 'password123')
    
    // Then sign out
    await page.getByRole('button', { name: /sign out/i }).click()
    
    // Should redirect to home
    await expect(page).toHaveURL('/')
  })

  test('protected routes redirect to sign in', async ({ page }) => {
    await page.goto('/dashboard')
    
    // Should redirect to sign in
    await expect(page).toHaveURL('/auth/signin')
  })
})
```

### Accessibility Testing

```typescript
// e2e/accessibility.spec.ts
import { test, expect } from '@playwright/test'
import AxeBuilder from '@axe-core/playwright'

test.describe('Accessibility Tests', () => {
  test('home page should not have accessibility violations', async ({ page }) => {
    await page.goto('/')
    
    const accessibilityScanResults = await new AxeBuilder({ page }).analyze()
    
    expect(accessibilityScanResults.violations).toEqual([])
  })

  test('sign in page should be accessible', async ({ page }) => {
    await page.goto('/auth/signin')
    
    const accessibilityScanResults = await new AxeBuilder({ page })
      .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
      .analyze()
    
    expect(accessibilityScanResults.violations).toEqual([])
  })

  test('keyboard navigation works correctly', async ({ page }) => {
    await page.goto('/auth/signin')
    
    // Tab through form elements
    await page.keyboard.press('Tab')
    await expect(page.getByTestId('email-input')).toBeFocused()
    
    await page.keyboard.press('Tab')
    await expect(page.getByTestId('password-input')).toBeFocused()
    
    await page.keyboard.press('Tab')
    await expect(page.getByRole('button', { name: /sign in/i })).toBeFocused()
  })
})
```

## Testing Best Practices

### Test Data Management

```typescript
// test/factories/user-factory.ts
export const userFactory = {
  build: (overrides = {}) => ({
    id: crypto.randomUUID(),
    email: 'test@example.com',
    name: 'Test User',
    role: 'user' as const,
    createdAt: new Date(),
    ...overrides
  }),
  
  buildMany: (count: number, overrides = {}) => 
    Array.from({ length: count }, () => userFactory.build(overrides))
}

// Usage in tests
const user = userFactory.build({ name: 'John Doe' })
const users = userFactory.buildMany(3)
```

### Custom Matchers

```typescript
// test/matchers.ts
import { expect } from 'vitest'

expect.extend({
  toBeValidEmail(received: string) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const pass = emailRegex.test(received)
    
    return {
      message: () => 
        pass ? 
          `expected ${received} not to be a valid email` :
          `expected ${received} to be a valid email`,
      pass,
    }
  },
  
  toHaveBeenCalledOnceWith(received: any, ...expected: any[]) {
    const pass = received.mock.calls.length === 1 && 
                 received.mock.calls[0].every((arg: any, i: number) => 
                   arg === expected[i]
                 )
    
    return {
      message: () => 
        pass ? 
          `expected function not to have been called once with ${expected}` :
          `expected function to have been called once with ${expected}`,
      pass,
    }
  }
})

// Usage
expect('test@example.com').toBeValidEmail()
expect(mockFn).toHaveBeenCalledOnceWith('arg1', 'arg2')
```

### Test Organization

```
__tests__/
├── components/           # Component tests
│   ├── ui/
│   └── forms/
├── hooks/               # Hook tests  
├── lib/                 # Utility function tests
│   ├── data/           # Database layer tests
│   └── utils/          # Helper function tests
├── pages/              # Page component tests
└── api/                # API route tests

e2e/
├── pages/              # Page Object Models
├── fixtures/           # Test data
├── auth.spec.ts        # Authentication flows
├── user-flows.spec.ts  # User journey tests
└── accessibility.spec.ts # A11y tests

test/
├── setup.ts            # Test configuration
├── factories/          # Test data factories
├── matchers.ts         # Custom matchers
└── mocks/              # Shared mocks
```

## Coverage Goals

- **Unit Tests**: 80%+ code coverage for utilities and business logic
- **Integration Tests**: Critical user flows and API endpoints
- **E2E Tests**: Happy paths and critical business scenarios
- **Accessibility Tests**: All public pages

## Performance Testing

```typescript
// __tests__/performance/api-performance.test.ts
import { performance } from 'perf_hooks'

describe('API Performance', () => {
  it('should respond to user creation within 500ms', async () => {
    const start = performance.now()
    
    await createUser({
      email: 'test@example.com',
      name: 'Test User'
    })
    
    const end = performance.now()
    const duration = end - start
    
    expect(duration).toBeLessThan(500) // 500ms threshold
  })
})
```

Remember: Write tests that focus on behavior, not implementation details. Test the "what" not the "how".