# Security Rules & Best Practices

You are an expert security-focused developer working with Next.js 14+, TypeScript, and modern web security practices.

## Core Security Principles

- **Defense in Depth**: Implement multiple layers of security controls
- **Least Privilege**: Grant minimum necessary permissions
- **Input Validation**: Validate all inputs at boundaries
- **Output Encoding**: Encode all outputs to prevent injection
- **Secure by Default**: Choose secure configurations over convenience

## Authentication & Authorization

### NextAuth.js v5 Patterns

```typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth"
import { NextAuthConfig } from "next-auth"
import { PrismaAdapter } from "@auth/prisma-adapter" // or Supabase adapter
import CredentialsProvider from "next-auth/providers/credentials"
import { compare } from "bcryptjs"
import { z } from "zod"

const loginSchema = z.object({
  email: z.string().email("Invalid email").toLowerCase(),
  password: z.string().min(8, "Password must be at least 8 characters")
})

export const authConfig: NextAuthConfig = {
  adapter: PrismaAdapter(prisma), // or SupabaseAdapter
  providers: [
    CredentialsProvider({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      authorize: async (credentials) => {
        try {
          const { email, password } = loginSchema.parse(credentials)
          
          // Validate user in database
          const user = await getUserByEmail(email)
          if (!user || !await compare(password, user.hashedPassword)) {
            return null
          }
          
          return {
            id: user.id,
            email: user.email,
            role: user.role
          }
        } catch {
          return null
        }
      }
    })
  ],
  session: { strategy: "jwt" },
  callbacks: {
    jwt: ({ token, user }) => {
      if (user) {
        token.role = user.role
      }
      return token
    },
    session: ({ session, token }) => {
      session.user.role = token.role
      return session
    }
  },
  pages: {
    signIn: "/auth/signin",
    error: "/auth/error"
  }
}
```

### Middleware Protection Patterns

```typescript
// middleware.ts
import { NextResponse } from "next/server"
import { auth } from "@/app/api/auth/[...nextauth]/route"
import { ratelimit } from "@/lib/rate-limit"

export async function middleware(request: NextRequest) {
  // Rate limiting
  const ip = request.ip ?? '127.0.0.1'
  const { success } = await ratelimit.limit(ip)
  if (!success) {
    return new NextResponse('Too Many Requests', { status: 429 })
  }
  
  // Authentication for protected routes
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    const session = await auth()
    if (!session) {
      return NextResponse.redirect(new URL('/auth/signin', request.url))
    }
  }
  
  // Admin routes
  if (request.nextUrl.pathname.startsWith('/admin')) {
    const session = await auth()
    if (!session || session.user.role !== 'admin') {
      return new NextResponse('Forbidden', { status: 403 })
    }
  }
  
  return NextResponse.next()
}

export const config = {
  matcher: ['/dashboard/:path*', '/admin/:path*', '/api/protected/:path*']
}
```

## Input Validation & Sanitization

### Zod Schema Patterns

```typescript
// lib/validations/auth.ts
import { z } from "zod"

export const registerSchema = z.object({
  email: z.string()
    .email("Invalid email address")
    .toLowerCase()
    .transform((email) => email.trim()),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, 
           "Password must contain uppercase, lowercase, number and special character"),
  name: z.string()
    .min(2, "Name must be at least 2 characters")
    .max(50, "Name must be less than 50 characters")
    .regex(/^[a-zA-Z\s]+$/, "Name can only contain letters and spaces")
    .transform((name) => name.trim())
})

export const emailSchema = z.string()
  .email("Invalid email address")
  .toLowerCase()
  .transform((email) => email.trim())

// API Route validation
export function validateRequest<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): { success: true; data: T } | { success: false; error: string } {
  try {
    const result = schema.parse(data)
    return { success: true, data: result }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { 
        success: false, 
        error: error.errors.map(e => e.message).join(', ') 
      }
    }
    return { success: false, error: 'Invalid input data' }
  }
}
```

### API Route Security Patterns

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from "next/server"
import { auth } from "@/app/api/auth/[...nextauth]/route"
import { ratelimit } from "@/lib/rate-limit"
import { validateRequest } from "@/lib/validations/auth"
import { createUserSchema } from "@/lib/validations/user"

export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const ip = request.ip ?? '127.0.0.1'
    const { success } = await ratelimit.limit(ip)
    if (!success) {
      return NextResponse.json(
        { error: 'Too many requests' }, 
        { status: 429 }
      )
    }
    
    // Authentication check
    const session = await auth()
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' }, 
        { status: 401 }
      )
    }
    
    // Input validation
    const body = await request.json()
    const validation = validateRequest(createUserSchema, body)
    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error }, 
        { status: 400 }
      )
    }
    
    // Business logic here
    const user = await createUser(validation.data)
    
    return NextResponse.json(
      { user: { id: user.id, email: user.email } }, // Don't expose sensitive data
      { status: 201 }
    )
    
  } catch (error) {
    console.error('API Error:', error)
    return NextResponse.json(
      { error: 'Internal server error' }, 
      { status: 500 }
    )
  }
}
```

## Content Security & Headers

### Next.js Security Headers

```typescript
// next.config.ts
const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on'
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'Referrer-Policy',
    value: 'origin-when-cross-origin'
  },
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline' https://va.vercel-scripts.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' blob: data: https:;
      font-src 'self';
      connect-src 'self' wss: https:;
    `.replace(/\s{2,}/g, ' ').trim()
  }
]
```

### Environment Variables Security

```typescript
// lib/env.ts - Runtime environment validation
import { z } from "zod"

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string().min(32, "NEXTAUTH_SECRET must be at least 32 characters"),
  NEXTAUTH_URL: z.string().url().optional(),
  
  // API Keys (mark as sensitive)
  STRIPE_SECRET_KEY: z.string().startsWith('sk_'),
  RESEND_API_KEY: z.string().startsWith('re_'),
  
  // Feature flags
  NODE_ENV: z.enum(['development', 'test', 'production']).default('development')
})

export const env = envSchema.parse(process.env)

// Type-safe environment access
declare global {
  namespace NodeJS {
    interface ProcessEnv extends z.infer<typeof envSchema> {}
  }
}
```

## Rate Limiting & DoS Protection

```typescript
// lib/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit"
import { Redis } from "@upstash/redis"

// Configure different limits for different endpoints
export const authRateLimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(5, "15 m"), // 5 attempts per 15 minutes
  analytics: true
})

export const apiRateLimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, "1 h"), // 100 requests per hour
  analytics: true
})

export const publicRateLimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(1000, "1 h"), // 1000 requests per hour
  analytics: true
})
```

## Database Security

### Query Safety Patterns

```typescript
// BAD: SQL injection vulnerable
const users = await prisma.$queryRaw`
  SELECT * FROM users WHERE email = ${email}
`

// GOOD: Parameterized queries
const users = await prisma.user.findMany({
  where: { 
    email: {
      equals: email,
      mode: 'insensitive'
    }
  },
  select: {
    id: true,
    email: true,
    name: true
    // Never select passwords or sensitive fields
  }
})

// Row Level Security (if using Supabase)
const { data, error } = await supabase
  .from('users')
  .select('id, email, name')
  .eq('id', userId)
  .single()
```

### Password Security

```typescript
// lib/auth/password.ts
import bcrypt from "bcryptjs"

const SALT_ROUNDS = 12

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS)
}

export async function verifyPassword(
  password: string, 
  hashedPassword: string
): Promise<boolean> {
  return bcrypt.compare(password, hashedPassword)
}

// Password strength validation
const passwordSchema = z.string()
  .min(8, "Password must be at least 8 characters")
  .regex(/^(?=.*[a-z])/, "Password must contain at least one lowercase letter")
  .regex(/^(?=.*[A-Z])/, "Password must contain at least one uppercase letter")
  .regex(/^(?=.*\d)/, "Password must contain at least one number")
  .regex(/^(?=.*[@$!%*?&])/, "Password must contain at least one special character")
```

## Error Handling & Logging

### Secure Error Responses

```typescript
// utils/error-handler.ts
export function handleAPIError(error: unknown): NextResponse {
  if (error instanceof z.ZodError) {
    return NextResponse.json(
      { 
        error: 'Validation failed',
        details: error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        }))
      },
      { status: 400 }
    )
  }
  
  if (error instanceof AuthError) {
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 401 }
    )
  }
  
  // Log full error details server-side only
  console.error('API Error:', error)
  
  // Return generic error to client
  return NextResponse.json(
    { error: 'Internal server error' },
    { status: 500 }
  )
}
```

## OWASP Top 10 Protection

### A01: Broken Access Control
- ✅ Implement middleware for route protection
- ✅ Validate user permissions for every action
- ✅ Use role-based access control (RBAC)

### A02: Cryptographic Failures
- ✅ Use bcrypt for password hashing (SALT_ROUNDS = 12)
- ✅ Validate NEXTAUTH_SECRET minimum length
- ✅ Use HTTPS in production (security headers)

### A03: Injection
- ✅ Use Prisma/Supabase ORM (prevents SQL injection)
- ✅ Validate all inputs with Zod schemas
- ✅ Implement Content Security Policy

### A04: Insecure Design
- ✅ Rate limiting on authentication endpoints
- ✅ Secure session management with NextAuth
- ✅ Input validation at every boundary

### A05: Security Misconfiguration
- ✅ Remove X-Powered-By header
- ✅ Set secure HTTP headers
- ✅ Environment variable validation

## Security Checklist

- [ ] All user inputs validated with Zod schemas
- [ ] Rate limiting implemented on auth endpoints
- [ ] HTTPS enforced in production
- [ ] Security headers configured
- [ ] Environment variables validated at startup
- [ ] Passwords properly hashed with bcrypt
- [ ] Session management with NextAuth.js
- [ ] CSRF protection enabled (NextAuth default)
- [ ] Content Security Policy configured
- [ ] Error messages don't leak sensitive information
- [ ] Database queries use ORM (no raw SQL)
- [ ] Dead code and unused dependencies removed

## Security Testing

```typescript
// __tests__/security/auth.test.ts
import { hashPassword, verifyPassword } from "@/lib/auth/password"

describe('Password Security', () => {
  it('should hash passwords securely', async () => {
    const password = 'TestPassword123!'
    const hashed = await hashPassword(password)
    
    expect(hashed).not.toBe(password)
    expect(hashed).toMatch(/^\$2[axy]\$12\$/)
    expect(await verifyPassword(password, hashed)).toBe(true)
    expect(await verifyPassword('wrong', hashed)).toBe(false)
  })
})
```

Remember: Security is not a feature you add at the end—it must be designed into every component from the beginning.